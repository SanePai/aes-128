import numpy as np

class aes:
    sBox = []
    GaloisF2 = []
    GaloisF3 = []
    RCON = []

    def __init__(self):
        self.init_tables()

    # Initialize Tables
    def init_tables(self):
        # AES S-Box
        self.sBox = [
            0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
            0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
            0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
            0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
            0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
            0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
            0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
            0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
            0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
            0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
            0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
            0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
            0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
            0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
            0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
            0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
        ]

        # GF 2^8 Multiplication by 2
        self.GaloisF2 = [
            0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
            0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
            0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
            0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
            0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
            0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
            0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
            0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
            0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
            0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
            0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
            0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
            0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
            0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
            0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
            0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5
        ]

        # GF 2^8 Multiplication by 3
        self.GaloisF3 = [
            0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
            0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
            0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
            0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
            0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
            0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
            0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
            0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
            0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
            0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
            0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
            0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
            0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
            0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
            0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
            0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a
        ]

        # RCON (round constant) table for ten rounds (x^i-1 in Keyschedule)
        self.RCON = ["01", "02", "04", "08", "10", "20", "40", "80", "1b", "36"]

    def change_s_box(self, ab):
        '''
        Function to modify s-box from (a,b).
        Input: s_box, ab - tuple calculated from ID numbers
        Output: Modifies s-box in place. 
        '''    
        sb = self.sBox
        sb = np.reshape(sb, (16,16))
        (a,b) = ab
        temp = sb[a,:].copy()
        sb[a,:] = sb[b,:]
        sb[b,:] = temp
        self.sBox = sb.reshape(1,256).tolist()[0]

    # Initialize state matrix
    def init_state_mat(self, plaintext):
        '''
        Initialize the state matrix by splitting the plaintext into 16 groups of 2 hex numbers (8 bits) each.
        The state matrix is a 1x16 matrix and the elements are column wise (not row wise)
        Input: Plaintext
        Output: state matrix
        '''
        state = [plaintext[2*i:2*(i+1)] for i in range(len(plaintext)//2)]
        return state

    def xor(self, left, right):
        '''
        Helper function to perform XOR on two hex numbers and output a hex number (2-digit)
        Input: 2 hex numbers to be XORed
        Output: hex output
        '''
        out = int('0x{}'.format(left), 16) ^ int('0x{}'.format(right), 16)
        out = str(hex(out))[2:]
        if len(out) < 2:
            out = "0" + out
        return out

    def fnT(self, word, round):
        '''
        Helper function to calculate T[W[4i-1]] in key schedule
        Input: W[4i-1], round (to get the RCON (x^i-1) for that round)
        Output: T[W[4i-1]]
        '''
        output = [word[2*i:2*(i+1)] for i in range(len(word)//2)]
        output = output[1:] + output[:1]

        for index in range(len(output)):
            out = int(f"0x{output[index]}", 16)
            out = str(hex(self.sBox[out]))[2:]

            if len(out) < 2:
                out = "0" + out
            output[index] = out

        output[0] = self.xor(output[0], self.RCON[round])
        output = "".join(output)
        return output

    def expand_key(self, key, round):
        '''
        Function to expand the key and get the round key for the next round
        Input: Current key, round number
        Output: New key
        '''
        words = []
        roundKey = [None, None, None, None]

        while key:
            words.append(key[:8])
            key = key[8:]

        roundKey[0] = self.xor(words[0], self.fnT(words[3], round)).zfill(8)
        roundKey[1] = self.xor(words[1], roundKey[0]).zfill(8)
        roundKey[2] = self.xor(words[2], roundKey[1]).zfill(8)
        roundKey[3] = self.xor(words[3], roundKey[2]).zfill(8)

        return roundKey

    # Key Addition
    def add_round_key(self, state, key):
        '''
        Add round key to the state
        Input: Current state, key
        Output: New state
        '''
        state_string = ''.join(state)
        key_string = ''.join(key)
        state_string = self.xor(state_string, key_string).zfill(len(state_string))
        new_state = [state_string[2*i:2*(i+1)] for i in range(len(state_string)//2)]

        return new_state

    # Byte Substitution
    def sub_bytes(self, state):
        '''
        Substitute bytes from S-box
        Input: State
        Output: New state
        '''
        new_state = []

        for byte in state:
            out = int(f"0x{byte}", 16)
            out = str(hex(self.sBox[out]))[2:]

            if len(out) < 2:
                out = "0" + out

            new_state.append(out)

        return new_state

    # Shift Rows
    def shift_rows(self, state):
        '''
        Shift rows cyclically
        Row 0 - No shift
        Row 1 - Shift by 1
        Row 2 - Shift by 2
        Row 3 - Shift by 3
        Input: Current state
        Output: New state
        '''
        state = np.reshape(state, (4,4)).T
        state[1] = np.append(state[1, 1:], state[1, :1])
        state[2] = np.append(state[2, 2:], state[2, :2])
        state[3] = np.append(state[3, 3:], state[3, :3])
        state = np.resize(state.T, (1,16)).tolist()[0]
        return state

    # Mix Columns
    def col_matrix_mult(self, state_col):
        '''
        Helper function to multiply with the M matrix
        M = [[02 03 01 01]
             [01 02 03 01]
             [01 01 02 03]
             [03 01 01 02]]
        Since the state matrix is column wise, the multiplication here is with the transpose
        of M. Therefore the new state matrix would also be column wise.
        Input - 4 elements from the state matrix (one column)
        Output - 4 elements from the new state matrix (one column)
        '''
        new_state_col = []

        one = self.GaloisF2[int(f"0x{state_col[0]}", 16)]
        two = self.GaloisF3[int(f"0x{state_col[1]}", 16)]
        three = int(f"0x{state_col[2]}", 16)
        four = int(f"0x{state_col[3]}", 16)

        out = one ^ two ^ three ^ four
        out = str(hex(out))[2:]
        if len(out) < 2:
            out = "0" + out
        new_state_col.append(out)

        one = int(f"0x{state_col[0]}", 16)
        two = self.GaloisF2[int(f"0x{state_col[1]}", 16)]
        three = self.GaloisF3[int(f"0x{state_col[2]}", 16)]
        four = int(f"0x{state_col[3]}", 16)

        out = one ^ two ^ three ^ four
        out = str(hex(out))[2:]
        if len(out) < 2:
            out = "0" + out
        new_state_col.append(out)

        one = int(f"0x{state_col[0]}", 16)
        two = int(f"0x{state_col[1]}", 16)
        three = self.GaloisF2[int(f"0x{state_col[2]}", 16)]
        four = self.GaloisF3[int(f"0x{state_col[3]}", 16)]

        out = one ^ two ^ three ^ four
        out = str(hex(out))[2:]
        if len(out) < 2:
            out = "0" + out
        new_state_col.append(out)

        one = self.GaloisF3[int(f"0x{state_col[0]}", 16)]
        two = int(f"0x{state_col[1]}", 16)
        three = int(f"0x{state_col[2]}", 16)
        four = self.GaloisF2[int(f"0x{state_col[3]}", 16)]

        out = one ^ two ^ three ^ four
        out = str(hex(out))[2:]
        if len(out) < 2:
            out = "0" + out
        new_state_col.append(out)
        return new_state_col

    def mix_cols(self, state):
        '''
        Mix columns by multiplying with the M matrix
        Input: Current state
        Output: New state
        '''
        new_state = []
        for i in range(4):
            new_state += self.col_matrix_mult(state[:4])
            state = state[4:]

        return new_state

    def encrypt(self, plaintext, key):
        '''
        Encrypt using AES
        R0 - ARK
        R1 to R9 - BS, SR, MC, ARK
        R10 - BS , SR, ARK
        Input: plaintext, key
        Output: all_states - State after each round, all_keys - Keys for each round
        '''
        all_keys=[]
        all_states = []
        state = self.init_state_mat(plaintext)
        all_states.append("".join((map(str, state))))
        # Round 0 ARK
        state = self.add_round_key(state, key)
        all_keys.append(key)
        all_states.append("".join((map(str, state))))
        
        for round in range(10):
            #BS
            state = self.sub_bytes(state)

            #SR
            state = self.shift_rows(state)

            #MC
            if round < 9:
                state = self.mix_cols(state)
            
            #ARK
            key = self.expand_key("".join(key), round)
            state = self.add_round_key(state, key)
            all_states.append("".join((map(str, state))))
            all_keys.append("".join((map(str, key))))

        return all_states,all_keys

def string_with_spaces(string, number):
    '''
    Helper function to print a string with spaces after every few letters (number)
    '''
    x = []
    string = string.upper()
    x = [string[number*i:number*(i+1)] for i in range(len(string)//number)]
    return " ".join(x)


if __name__ == "__main__":
    ids = [(110113877, "Kushaal Tummala"), (110107612, "Lakshmi Narasimha SriHarsha Modukuri"), (110107699, "Maria Joseph Kumar Nagothu")]
    # Get group code
    s1 = 0
    s2 = 0
    for i in range(len(ids)):
        (id,name) = ids[i]
        s1 += id%10
        s2 += (int(id/10))%10
        print(f"ID{i+1} = {id} ({name})")
    a = s1%8
    b = (s2%8)+8
    print(f"Group Code (A,B) = ({a},{b})")

    plaintext = "00112233445566778899AABBCCDDEEFF"
    key = "000102030405060708090A0B0C0D0E0F"

    print(f"Assigned Plaintext and Key:\n\t{string_with_spaces(plaintext,2)}\n\t{string_with_spaces(key,2)}\n")
    print("This program is written in Python 3.10.4")

    aes = aes()
    aes.change_s_box((a,b))
    [all_states,all_keys] = aes.encrypt(plaintext, key)
    
    print("-"*len("Key Schedule Results for Each Round with the modified ABS"))
    print("Key Schedule Results for Each Round with the modified ABS")
    print("-"*len("Key Schedule Results for Each Round with the modified ABS"))
    for i in range(len(all_keys)):
        print(f"Round {i}:\n\tKey: {string_with_spaces(all_keys[i],2)}")

    print("-"*len("Data Results for Each Round with the modified AES"))
    print("Data Results for Each Round with the modified AES")
    print("-"*len("Data Results for Each Round with the modified AES"))
    for i in range(len(all_keys)):
        print(f"Round {i}:")
        if i == 0:
            print(f"-----Start: {string_with_spaces(all_states[0],2)}")
        print(f"----Output: {string_with_spaces(all_states[i+1],2)}")

    print("-"*60) 